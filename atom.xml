<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Houseowo]]></title>
  <subtitle><![CDATA[Lwxiang's Blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://houseowo.me/"/>
  <updated>2016-02-22T12:25:12.000Z</updated>
  <id>http://houseowo.me/</id>
  
  <author>
    <name><![CDATA[Lwxiang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[usaco2005open Navigating the City]]></title>
    <link href="http://houseowo.me/2013/02/14/POJ2435/"/>
    <id>http://houseowo.me/2013/02/14/POJ2435/</id>
    <published>2013-02-14T06:51:01.000Z</published>
    <updated>2016-02-22T12:25:12.000Z</updated>
    <content type="html"><![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=2435" title="Navigating the City" target="_blank" rel="external">POJ2435</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意：</p>
<p>给一张各种字符组成的图，S,E分别为起点终点</p>
<pre><code>+是十字路口

-,|是横的竖的街道

.不能走
</code></pre><p>+-+-+.+-+-+</p>
<p>|…|…..|</p>
<p>+-+.+-+-+-+ </p>
<p>..|…….|</p>
<p>S-+-+-+.E-+</p>
<p>比如这张图</p>
<a id="more"></a>
<p>现在要求是输出从起点到终点的最短路径 </p>
<p>路径表示为 dir tot</p>
<pre><code>dir 表示走的方向 用 E,W,S,N表示

tot 表示向这个方向走tot个十字路口
</code></pre><h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>很显然是广搜，从起点广搜到终点,way[]记录过来的点和方向</p>
<p>然后从终点dfs回去，如果该点的way[]，也就是来的方向和last不一样，就说明这是个拐点</p>
<p>如果同时是拐点且为十字路口，那么在回溯的时候把路径输出</p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><p>回溯的时候用sum记录从上一个输出的点到现在过了几个十字路口</p>
<h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><p>注意”-“和”|”只能扩展两个方向，而十字路口和S,E可以扩展四个方向</p>
<p>六、源程序</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Program Lwx;</span><br><span class="line"><span class="keyword">Const</span> 	mv:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">4</span>, <span class="number">1</span>..<span class="number">2</span>] <span class="keyword">of</span> longint=((<span class="number">1</span>, <span class="number">0</span>),(-<span class="number">1</span>, <span class="number">0</span>),(<span class="number">0</span>, <span class="number">1</span>),(<span class="number">0</span>,- <span class="number">1</span>));</span><br><span class="line">      	ba:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">4</span>] <span class="keyword">of</span> char=(<span class="string">'S'</span>, <span class="string">'N'</span>, <span class="string">'E'</span>, <span class="string">'W'</span>);</span><br><span class="line"><span class="keyword">Var</span> 	n, m:longint;</span><br><span class="line">    	map:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">100</span>] <span class="keyword">of</span> string;</span><br><span class="line">    	way:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">100</span>, <span class="number">1</span>..<span class="number">100</span>, <span class="number">1</span>..<span class="number">3</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	get:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">100</span>, <span class="number">1</span>..<span class="number">100</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	fns:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">100000</span>, <span class="number">1</span>..<span class="number">2</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	i, j, k, l, a, b, x, y, z, sx, sy, ex, ey:longint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">dfs</span><span class="params">(x, y, g:longint)</span>;</span></span><br><span class="line"><span class="keyword">Var</span> 	a, b, c, d:longint;</span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	<span class="keyword">if</span> (x = sx)<span class="keyword">and</span>(y = sy) <span class="keyword">then</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		k := <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">exit</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line"> 	<span class="keyword">if</span> way[x, y, <span class="number">3</span>] &lt;&gt; g <span class="keyword">then</span> d := <span class="number">1</span> <span class="keyword">else</span> d := <span class="number">0</span>;</span><br><span class="line">  	dfs(way[x, y, <span class="number">1</span>], way[x, y, <span class="number">2</span>], way[x, y, <span class="number">3</span>]);</span><br><span class="line">  	<span class="keyword">if</span> (map[x, y] = <span class="string">'+'</span>)<span class="keyword">or</span>(map[x, y] = <span class="string">'E'</span>) <span class="keyword">then</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		k := k + <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">if</span> d = <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			writeln(ba[way[x, y, <span class="number">3</span>]], <span class="string">' '</span>, k);</span><br><span class="line">    			k := <span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	assign(input, <span class="string">'test.in'</span>); reset(input);</span><br><span class="line">  	readln(n, m);</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> n*<span class="number">2</span>-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		readln(map[i]);</span><br><span class="line">    		<span class="keyword">for</span> j := <span class="number">1</span> <span class="keyword">to</span> m*<span class="number">2</span>-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			<span class="keyword">if</span> map[i, j] = <span class="string">'S'</span> <span class="keyword">then</span></span><br><span class="line">      			<span class="keyword">begin</span>	</span><br><span class="line">        			sx := i;</span><br><span class="line">        			sy := j;</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">      			<span class="keyword">if</span> map[i, j] = <span class="string">'E'</span> <span class="keyword">then</span></span><br><span class="line">      			<span class="keyword">begin</span></span><br><span class="line">        			ex := i;</span><br><span class="line">        			ey := j;</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	close(input);</span><br><span class="line">  	fillchar(get, sizeof(get), $ff);</span><br><span class="line">  	get[sx, sy] := <span class="number">0</span>;</span><br><span class="line">  	fns[<span class="number">1</span>, <span class="number">1</span>] := sx;</span><br><span class="line">  	fns[<span class="number">1</span>, <span class="number">2</span>] := sy;</span><br><span class="line">  	i := <span class="number">0</span>; j := <span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">while</span> i &lt; j <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		x := fns[i+<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">    		y := fns[i+<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    		<span class="keyword">for</span> k := <span class="number">1</span> <span class="keyword">to</span> <span class="number">4</span> <span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			<span class="keyword">if</span> (map[x, y] = <span class="string">'|'</span>)<span class="keyword">and</span>(k &gt;= <span class="number">3</span>) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">      			<span class="keyword">if</span> (map[x, y] = <span class="string">'-'</span>)<span class="keyword">and</span>(k &lt;= <span class="number">2</span>) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">      			a := x + mv[k, <span class="number">1</span>];</span><br><span class="line">      			b := y + mv[k, <span class="number">2</span>];</span><br><span class="line">      			<span class="keyword">if</span> (a &lt; <span class="number">1</span>)<span class="keyword">or</span>(a &gt; n*<span class="number">2</span>-<span class="number">1</span>)<span class="keyword">or</span>(b &lt; <span class="number">1</span>)<span class="keyword">or</span>(b &gt; m*<span class="number">2</span>-<span class="number">1</span>) <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">      			<span class="keyword">if</span> map[a, b] = <span class="string">'.'</span> <span class="keyword">then</span> <span class="keyword">continue</span>;</span><br><span class="line">      			<span class="keyword">if</span> get[a, b] = -<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">      			<span class="keyword">begin</span></span><br><span class="line">        			get[a, b] := get[x, y] + <span class="number">1</span>;</span><br><span class="line">        			way[a, b, <span class="number">1</span>] := x;</span><br><span class="line">        			way[a, b, <span class="number">2</span>] := y;</span><br><span class="line">        			way[a, b, <span class="number">3</span>] := k;</span><br><span class="line">        			inc(j);</span><br><span class="line">        			fns[j, <span class="number">1</span>] := a;</span><br><span class="line">        			fns[j, <span class="number">2</span>] := b;</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line">    		inc(i);</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	dfs(ex, ey, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=2435" title="Navigating the City">POJ2435</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意：</p>
<p>给一张各种字符组成的图，S,E分别为起点终点</p>
<pre><code>+是十字路口

-,|是横的竖的街道

.不能走
</code></pre><p>+-+-+.+-+-+</p>
<p>|…|…..|</p>
<p>+-+.+-+-+-+ </p>
<p>..|…….|</p>
<p>S-+-+-+.E-+</p>
<p>比如这张图</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[usaco2005jan Sumsets]]></title>
    <link href="http://houseowo.me/2013/02/14/POJ2229/"/>
    <id>http://houseowo.me/2013/02/14/POJ2229/</id>
    <published>2013-02-14T05:20:32.000Z</published>
    <updated>2016-02-22T12:25:12.000Z</updated>
    <content type="html"><![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=2229" title="Sumsets" target="_blank" rel="external">POJ2229</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给出一个正整数N(&lt;=10^6)，可知N可分解为多个2^K(&gt;=0)的数相加</p>
<p>如： 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1；</p>
<pre><code>= 1 + 1 + 1 + 1 + 1 + 2；

= 1 + 1 + 1 + 2 + 2；

= 1 + 1 + 1 + 4；

= 1 + 2 + 2 + 2；

= 1 + 2 + 4；      
</code></pre><p>共6种；</p>
<p>求种数。</p>
<p>刚拿到题目的时候，我联想到了整数的划分。</p>
<a id="more"></a>
<p>套用那个动归方程去做。</p>
<p>即<code>F[I,J]</code> 表示，将I划分成最大为J的整数和。</p>
<p>这样 <code>F[I,J] = SIGMA{ F[I-J,K]  J&gt;=K }</code></p>
<p>这题便是，F[I,J] 表示，将I划分成最大为2^J(&gt;=0)的整数和。</p>
<p>方程一样 <code>F[I,J] = SIGMA{ F[I-1,K] J&gt;=K }</code></p>
<p>可是这样做的时间复杂度为,O(n<em>logn</em>logn)，会超时。</p>
<p>但我又想到<code>F[I,J]</code> 只从 <code>F[I-J,0] + F[I-J,1] +...+ F[I-1,J]</code></p>
<p>这样可以用<code>C[I,J]</code> 表示 <code>F[I,J]</code> 的前缀和 </p>
<p>方程转移变成 <code>F[I,J] = C[I-J,T]</code>  其中<code>T = MIN { log(i-j) , j } (最大T,2^T不能超过I-J，T不能超过J)</code></p>
<pre><code>`C[I,J] = C[I,J-1]+F[I,J]`
</code></pre><p>这样省去了K的那层循环，复杂度优化为O(n*logn)，非常遗憾，还是会超时。</p>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>想了半天以后，只能去看题解。</p>
<p>题解也是用动归。</p>
<p>用F[I]表示把I划分的种数。</p>
<p>则 在所有构成I的加数中，只有1是奇数。</p>
<p>若I为奇数，则必然至少含1个1.且这个1必然独立。则<code>F[I] = F[I-1]</code></p>
<p>若I为偶数，则若含1，至少含2个，且这2个1也独立。<code>F[I] = F[I-2]</code></p>
<pre><code>若不含1，则所有的加数都是偶数，所以所有的加数都可以映射到其1/2，如 8 = 2 + 2 + 4 可以映射到 4 = 1 + 1 + 2

                                则`F[I] = F[I/2]`
</code></pre><p>综上，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i] = f[i-<span class="number">1</span>]   &#123;i mod <span class="number">2</span>=<span class="number">1</span>&#125;               </span><br><span class="line"></span><br><span class="line">f[i-<span class="number">2</span>] + f[i/<span class="number">2</span>] &#123;i mod <span class="number">2</span>=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><p>初始 f[1]=1 f[2]=2</p>
<h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><h2 id="u6E90_u7A0B_u5E8F"><a href="#u6E90_u7A0B_u5E8F" class="headerlink" title="源程序"></a>源程序</h2><p>解一：(优化后)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Program Lwx;</span><br><span class="line">Const 	md=<span class="number">1000000000</span>;</span><br><span class="line">Var 	n:longint;</span><br><span class="line">    	a:<span class="built_in">array</span>[<span class="number">0.</span><span class="number">.1000000</span>, <span class="number">0.</span><span class="number">.20</span>] of longint;</span><br><span class="line">    	c:<span class="built_in">array</span>[<span class="number">0.</span><span class="number">.1000000</span>, -<span class="number">1.</span><span class="number">.20</span>] of longint;</span><br><span class="line">    	b:<span class="built_in">array</span>[<span class="number">0.</span><span class="number">.100</span>] of longint;</span><br><span class="line">    	ans, i, j, k, l, x, y, z:longint;</span><br><span class="line"></span><br><span class="line"><span class="function">Begin</span><br><span class="line">  	<span class="title">readln</span><span class="params">(n)</span></span>;</span><br><span class="line">  	b[<span class="number">0</span>] := <span class="number">1</span>; k := <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">while</span> b[k] &lt; <span class="function">n <span class="keyword">do</span></span><br><span class="line">  	begin</span><br><span class="line">   		<span class="title">inc</span><span class="params">(k)</span></span>;</span><br><span class="line">   		b[k] := b[k-<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">  	end;</span><br><span class="line">  	c[<span class="number">1</span>, <span class="number">0</span>] := <span class="number">1</span>;</span><br><span class="line"> 	<span class="keyword">for</span> i := <span class="number">2</span> to n <span class="keyword">do</span></span><br><span class="line">  	begin</span><br><span class="line">   		c[i, -<span class="number">1</span>] := <span class="number">0</span>;</span><br><span class="line">   		<span class="keyword">for</span> j := <span class="number">0</span> to k <span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">if</span> b[j] &lt;= i then</span><br><span class="line">    		begin</span><br><span class="line">      			<span class="keyword">if</span> b[j] = i then begin a[i, j] := <span class="number">1</span>; <span class="keyword">continue</span>; end</span><br><span class="line">      			<span class="keyword">else</span> a[i, j] := <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      			y := trunc(ln(i-b[j])/ln(<span class="number">2</span>));</span><br><span class="line">      			<span class="keyword">if</span> y &gt; j then y := j;</span><br><span class="line">      			a[i, j] := (a[i,j ] + c[i-b[j], y]) mod md;</span><br><span class="line">      			c[i, j] := (c[i, j-<span class="number">1</span>] + a[i, j]) mod md;</span><br><span class="line">    		end <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  	end;</span><br><span class="line">  	ans := <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">0</span> to k <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">if</span> b[i] &lt;= n then ans := (ans + a[n, i]) mod md;</span><br><span class="line">  	write(ans);</span><br><span class="line">End.</span><br></pre></td></tr></table></figure>
<p>解二：(正解)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Program Lwx;</span><br><span class="line">Const 	md=<span class="number">1000000000</span>;</span><br><span class="line">Var 	a:<span class="built_in">array</span>[<span class="number">0.</span><span class="number">.1000000</span>] of longint;</span><br><span class="line">   	n,i,j,k,l:longint;</span><br><span class="line"></span><br><span class="line"><span class="function">Begin</span><br><span class="line">  <span class="title">read</span><span class="params">(n)</span></span>;</span><br><span class="line">  a[<span class="number">1</span>] := <span class="number">1</span>; a[<span class="number">2</span>] := <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">3</span> to n <span class="keyword">do</span> </span><br><span class="line">  <span class="keyword">if</span> i mod <span class="number">2</span> = <span class="number">1</span> then a[i] := a[i-<span class="number">1</span>] <span class="keyword">else</span> a[i] := (a[i-<span class="number">2</span>] + a[i div <span class="number">2</span>]) mod md;</span><br><span class="line">  write(a[n]);</span><br><span class="line">End.</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=2229" title="Sumsets">POJ2229</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给出一个正整数N(&lt;=10^6)，可知N可分解为多个2^K(&gt;=0)的数相加</p>
<p>如： 7 = 1 + 1 + 1 + 1 + 1 + 1 + 1；</p>
<pre><code>= 1 + 1 + 1 + 1 + 1 + 2；

= 1 + 1 + 1 + 2 + 2；

= 1 + 1 + 1 + 4；

= 1 + 2 + 2 + 2；

= 1 + 2 + 4；      
</code></pre><p>共6种；</p>
<p>求种数。</p>
<p>刚拿到题目的时候，我联想到了整数的划分。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[usaco2008feb Eating Together]]></title>
    <link href="http://houseowo.me/2013/02/14/POJ3670/"/>
    <id>http://houseowo.me/2013/02/14/POJ3670/</id>
    <published>2013-02-13T18:20:07.000Z</published>
    <updated>2016-02-22T12:19:31.000Z</updated>
    <content type="html"><![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=3670" title="Eating Together" target="_blank" rel="external">POJ3670</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给定一个长度为N（N&lt;=30000）的仅包含1,2,3的串</p>
<p>求最长不下降子序列（正反均可）</p>
<a id="more"></a>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>刚开始以为必须用O(N^2)的不下降子序列的经典算法</p>
<p>可是30000的数据不允许 </p>
<p>可以发现串中只包含1，2，3三种数字</p>
<p>则在子序列S中，</p>
<p>若 s[i] = 1  则 s[i-1] = 1</p>
<p>   s[i] = 2     s[i-1] = 1 or 2</p>
<p>   s[i] = 3     s[i-1] = 1 or 2 or 3</p>
<p>可知在源串L中，离L[i]最近的以K(k=1,2,3)结尾的串</p>
<p>必然是最长的以K(K=1,2,3)结尾的串，可以反证</p>
<p>因此F[i]的决策来自于离i最近的F[j]=k(k=1,2,3)</p>
<p>所以 F[I] = MAX { B[K] + 1 ,1&lt;=K&lt;=L[I] }</p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><p>F[I]表示以L[I]结尾的最长子序列长度，B[K]表示以K结尾的最长子序列长度</p>
<h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><p>每次更新B[K] 记得反过来再做一遍</p>
<h2 id="u6E90_u7A0B_u5E8F"><a href="#u6E90_u7A0B_u5E8F" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Program Lwx;</span><br><span class="line">Var 	n:longint;</span><br><span class="line">    	a:array[1..30007] of longint;</span><br><span class="line">    	b:array[1..3] of longint;</span><br><span class="line">    	i, j, k, max:longint;</span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">Begin</span></span><br><span class="line">	readln(<span class="keyword">n</span>);</span></span><br><span class="line">	for i := 1 to n <span class="operator"><span class="keyword">do</span> <span class="keyword">read</span>(a[<span class="keyword">i</span>]);</span></span><br><span class="line">	fillchar(b, sizeof(b), 0);</span><br><span class="line">  	for i := 1 to n <span class="operator"><span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">k</span> := <span class="number">0</span>;</span></span><br><span class="line">    		for j := 1 to a[i] <span class="operator"><span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">if</span> b[j] &gt; <span class="keyword">k</span> <span class="keyword">then</span> <span class="keyword">k</span> := b[j];</span></span><br><span class="line">    		b[a[i]] := k + 1;</span><br><span class="line">  	<span class="operator"><span class="keyword">end</span>;</span></span><br><span class="line">  	max := 0;</span><br><span class="line">  	for i := 1 to 3 <span class="operator"><span class="keyword">do</span> <span class="keyword">if</span> b[<span class="keyword">i</span>] &gt; <span class="keyword">max</span> <span class="keyword">then</span> <span class="keyword">max</span> := b[<span class="keyword">i</span>];</span></span><br><span class="line">  	fillchar(b, sizeof(b), 0);</span><br><span class="line">  	for i := n downto 1 <span class="operator"><span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">k</span> := <span class="number">0</span>;</span></span><br><span class="line">    		for j := 1 to a[i] <span class="operator"><span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">if</span> b[j] &gt; <span class="keyword">k</span> <span class="keyword">then</span> <span class="keyword">k</span> := b[j];</span></span><br><span class="line">    		b[a[i]] := k + 1;</span><br><span class="line">  	<span class="operator"><span class="keyword">end</span>;</span></span><br><span class="line">  	for i := 1 to 3 <span class="operator"><span class="keyword">do</span> <span class="keyword">if</span> b[<span class="keyword">i</span>]  &gt;<span class="keyword">max</span> <span class="keyword">then</span> <span class="keyword">max</span> := b[<span class="keyword">i</span>];</span></span><br><span class="line">  	write(n - max);</span><br><span class="line"><span class="operator"><span class="keyword">End</span>.</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=3670" title="Eating Together">POJ3670</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给定一个长度为N（N&lt;=30000）的仅包含1,2,3的串</p>
<p>求最长不下降子序列（正反均可）</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[usaco2005oct Allowance]]></title>
    <link href="http://houseowo.me/2013/02/14/POJ3040/"/>
    <id>http://houseowo.me/2013/02/14/POJ3040/</id>
    <published>2013-02-13T18:20:07.000Z</published>
    <updated>2016-02-22T12:35:08.000Z</updated>
    <content type="html"><![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=3040" title="Allowance" target="_blank" rel="external">POJ3040</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意：</p>
<p>给定N(&lt;=20)种钞票,第i种面值为a[i],数量为b[i]      </p>
<p>每周要给奶牛C(&lt;=10^8)元的工资，求最多可以给几周。</p>
<p>注意：</p>
<p>1）给的工资每周不少于C元。</p>
<p>2）任意i,j  若a[i]&lt;a[j] 则 a[j]为a[i]的倍数</p>
<p>肯定是贪心，但问题是怎么贪</p>
<a id="more"></a>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>根据网上的题解和大表的结论</p>
<p>关键在于注意2，大的数一定是小的数的倍数。</p>
<p>于是大的数是可以由前面小数凑成的，性质其实一样，因此早取不会比晚取劣。</p>
<p>那么就是每次把能放的下的大数放进去，然后用小的补齐。</p>
<p>对于每一次取数 (取出的和大于等于C，就是付一次工资)</p>
<p>用d[]数组表示这次取数中，第k个数拿了d[k]个</p>
<p>rest = C 表示至少还要多少钱</p>
<p>1)第一轮从大到小取，对于第k个数，取到饱和，rest&gt;=0</p>
<p>  那么从大到小取 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest <span class="tag">div</span> <span class="tag">a</span>[k])&lt;=<span class="tag">b</span>[k] then d[k] = rest <span class="tag">div</span> <span class="tag">a</span>[k] </span><br><span class="line"></span><br><span class="line">                                <span class="keyword">else</span> d[k] = <span class="tag">b</span>[k]</span><br><span class="line"></span><br><span class="line">rest = rest - <span class="tag">a</span>[k]*d[k]</span><br></pre></td></tr></table></figure>
<p>2)第二轮从小到大取，对于第k个数，取到超过所需为止，rest&lt;=0</p>
<p>若 第k个数能够把剩下的工资补完,则 <code>d[k] = rest div a[k](除不尽要+1)  rest = 0</code></p>
<p>若 第k….不能…………….,则 <code>d[k] = b[k]                       rest = rest - b[k]*a[k]</code></p>
<p>这样得到了d[]数组</p>
<p>如果一次一次地做，肯定会超时。。</p>
<p>这样对于d[]数组，相当于一种给工资的方案，我们就可以统计这个方案最多可以用几次，然后再换一个方案。</p>
<p>对于第k个数，d[]方案可以使用的次数为 time[k] = b[k] div d[k]</p>
<p>找出最小的time[k]，就是这个方案可使用的次数</p>
<p>然后更新b[] ，<code>b[k] = b[k] - time[k]*d[k]</code></p>
<p>重复做，知道再也不能找出一种方案为止</p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><p>以上</p>
<h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><p>一定要注意两轮取数的差别，第一次的约束条件是rest&gt;=0 第二次的终止条件是rest&lt;=0</p>
<h2 id="u6E90_u7A0B_u5E8F"><a href="#u6E90_u7A0B_u5E8F" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">Program Lwx;</span><br><span class="line"><span class="keyword">Var</span> 	n, c:longint;</span><br><span class="line">    	a, b, d:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">20</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	i, j, k, l, x, y, z, use,ans:longint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	assign(input, <span class="string">'test.in'</span>); reset(input);</span><br><span class="line">  	readln(n, c);</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i], b[i]);</span><br><span class="line">  	close(input);</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> n-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">   	<span class="keyword">for</span> j := i+<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">   	<span class="keyword">if</span> a[i] &lt; a[j] <span class="keyword">then</span></span><br><span class="line">   	<span class="keyword">begin</span></span><br><span class="line">     		x := a[i]; a[i] :=a [j]; a[j] := x;</span><br><span class="line">     		x := b[i]; b[i] := b[j]; b[j] := x;</span><br><span class="line">   	<span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">  	ans := <span class="number">0</span>;</span><br><span class="line">  	i := <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">if</span> i &gt; n <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">    		<span class="keyword">if</span> b[i] = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			inc(i);</span><br><span class="line">      			<span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    		<span class="keyword">if</span> a[i] &gt;= c <span class="keyword">then</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			ans := ans + b[i];</span><br><span class="line">      			b[i] := <span class="number">0</span>;</span><br><span class="line">     			inc(i);</span><br><span class="line">      			<span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    		x := c;</span><br><span class="line">    		<span class="keyword">for</span> k := i <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			d[k] := <span class="number">0</span>;</span><br><span class="line">      			z := x <span class="keyword">div</span> a[k];</span><br><span class="line">      			<span class="keyword">if</span> z &lt;= b[k] <span class="keyword">then</span> d[k] := z <span class="keyword">else</span></span><br><span class="line">                        d[k] := b[k];</span><br><span class="line">      			x := x - a[k]*d[k];</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    		y := n;</span><br><span class="line">    		<span class="keyword">while</span> x &gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">   		<span class="keyword">begin</span></span><br><span class="line">      			<span class="keyword">if</span> y &lt; <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">break</span>;</span><br><span class="line">      			<span class="keyword">if</span> b[y] = d[y] <span class="keyword">then</span></span><br><span class="line">      			<span class="keyword">begin</span></span><br><span class="line">        			dec(y);</span><br><span class="line">        			<span class="keyword">continue</span>;</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">      		z := x <span class="keyword">div</span> a[y] + ord(x <span class="keyword">mod</span> a[y] &lt;&gt; <span class="number">0</span>);</span><br><span class="line">      		<span class="keyword">if</span> z + d[y] &lt;= b[y] <span class="keyword">then</span></span><br><span class="line">      		<span class="keyword">begin</span></span><br><span class="line">        		x := <span class="number">0</span>;</span><br><span class="line">        		d[y]:=d[y]+z;</span><br><span class="line">      			<span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">      			<span class="keyword">begin</span></span><br><span class="line">        			x := x - a[y]*(b[y] - d[y]);</span><br><span class="line">        			d[y] := b[y];</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line">    		<span class="keyword">if</span> x = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			z := maxlongint;</span><br><span class="line">      			<span class="keyword">for</span> k := i <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">      			<span class="keyword">if</span> d[k] &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">      			<span class="keyword">if</span> b[k] <span class="keyword">div</span> d[k] &lt; z <span class="keyword">then</span> z := b[k] <span class="keyword">div</span> d[k];</span><br><span class="line">      			<span class="keyword">if</span> z &lt; maxlongint <span class="keyword">then</span></span><br><span class="line">      			<span class="keyword">begin</span></span><br><span class="line">        			ans := ans+z;</span><br><span class="line">        			<span class="keyword">for</span> k := i <span class="keyword">to</span> n <span class="keyword">do</span> b[k] := b[k] - d[k]*z;</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">    		<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	<span class="keyword">write</span>(ans);</span><br><span class="line"><span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=3040" title="Allowance">POJ3040</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意：</p>
<p>给定N(&lt;=20)种钞票,第i种面值为a[i],数量为b[i]      </p>
<p>每周要给奶牛C(&lt;=10^8)元的工资，求最多可以给几周。</p>
<p>注意：</p>
<p>1）给的工资每周不少于C元。</p>
<p>2）任意i,j  若a[i]&lt;a[j] 则 a[j]为a[i]的倍数</p>
<p>肯定是贪心，但问题是怎么贪</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[usaco2007open Cheapest Palindrome]]></title>
    <link href="http://houseowo.me/2012/12/15/POJ3280/"/>
    <id>http://houseowo.me/2012/12/15/POJ3280/</id>
    <published>2012-12-15T05:20:32.000Z</published>
    <updated>2016-02-22T08:46:30.000Z</updated>
    <content type="html"><![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=3280" title="Cheapest Palindrome" target="_blank" rel="external">POJ3280</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给定一个长度为M（M&lt;=2000）的小写字母串</p>
<p>给定串中出现的N种字母的添加和删除代价</p>
<p>可以在任意位置加入或删除任意字母，代价如给定</p>
<p>求使原串变形为回文串的最小代价</p>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>刚开始的思路非常复杂，储存两个代价，并且递归处理</p>
<p>(left,right)之外的回文串(之间的已为回文)，然后分各种情况讨论。这又犯了想当然的毛病，而且每次都是打到一半才发现算法不完善，情况考虑未完整，影响很致命。</p>
<p>其实这题的解法很简单。</p>
<a id="more"></a>
<p>首先注意到当在处理(left,right)时，</p>
<p>如 …a(…)b… ()中为已处理完的回文串。此时删除和添加a所获得的效果和影响是一样的，因此我们只要在预处理时保留min(add[i],delete[i])就可以了。</p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><p>dp</p>
<h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><p>cost[left,right] 表示将left,right区间内字符串变成回文串</p>
<p>有三种情况 </p>
<ol>
<li><p>a(…)a 这类代价直接等于(…)中代价</p>
</li>
<li><p>a(…)b 有两种处理，</p>
<p>后处理 a : cost[a] + cost[ (…)b ]   </p>
<p>后处理 b : cost[b] + cost[ a(…) ]</p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cost[<span class="keyword">left</span>,<span class="keyword">right</span>] =</span><br><span class="line">    &#123;  </span><br><span class="line">       	cost[<span class="keyword">left</span>+<span class="number">1</span>,<span class="keyword">right</span>-<span class="number">1</span>]                                                     (<span class="keyword">if</span> word[<span class="keyword">left</span>]=word[<span class="keyword">right</span>]) </span><br><span class="line">       	<span class="built_in">min</span>( cost[<span class="keyword">left</span>+<span class="number">1</span>,<span class="keyword">right</span>] + pay[<span class="keyword">left</span>] , cost[<span class="keyword">left</span>,<span class="keyword">right</span>-<span class="number">1</span>] + pay[<span class="keyword">right</span>] )  (<span class="keyword">else</span>                     )   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><p>cost[i,i]=0 单个字符</p>
<p>cost[i,i-1]=0 空串</p>
<h2 id="u6E90_u7A0B_u5E8F"><a href="#u6E90_u7A0B_u5E8F" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Program</span> Lwx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Var</span> 	n, m:longint;</span><br><span class="line">    	word:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">2007</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	cost:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">26</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	tax:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2007</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	fur:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">2007</span>, <span class="number">0</span>..<span class="number">2007</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	i, j, k, l, x, y, z, ans:longint;</span><br><span class="line">    	q, w:char;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">min</span><span class="params">(a, b:longint)</span>:</span>longint;</span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	<span class="keyword">if</span> a &lt; b <span class="keyword">then</span> <span class="keyword">exit</span>(a); <span class="keyword">exit</span>(b);</span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">init</span>;</span></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	<span class="comment">//assign(input, 'test.in'); reset(input);</span></span><br><span class="line">  	readln(n, m);</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">read</span>(q);</span><br><span class="line">    		word[i] := ord(q) - ord(<span class="string">'a'</span>) + <span class="number">1</span>; <span class="comment">//用数字代替字母</span></span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	readln;</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		<span class="keyword">read</span>(q);</span><br><span class="line">    		readln(x, y);</span><br><span class="line">    		z := ord(q) - ord(<span class="string">'a'</span>) + <span class="number">1</span>;</span><br><span class="line">    		cost[z] := min(x, y); <span class="comment">//预处理出最小的处理代价</span></span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	<span class="comment">//close(input);</span></span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">main</span>;</span></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">0</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">for</span> j := <span class="number">0</span> <span class="keyword">to</span> m <span class="keyword">do</span> fur[i, j] := maxlongint;</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		fur[i, i] := <span class="number">0</span>;</span><br><span class="line">    		fur[i, i-<span class="number">1</span>] := <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> m-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">   	<span class="keyword">for</span> j := <span class="number">1</span> <span class="keyword">to</span> m-i <span class="keyword">do</span></span><br><span class="line">   	<span class="keyword">begin</span></span><br><span class="line">     		l := i + j;</span><br><span class="line">     		<span class="keyword">if</span> word[j] = word[l] <span class="keyword">then</span> <span class="keyword">begin</span> fur[j, l] := fur[j+<span class="number">1</span>, l-<span class="number">1</span>]; continue; <span class="keyword">end</span>; <span class="comment">//若是两边字母相同</span></span><br><span class="line">     		fur[j, l] := min(fur[j+<span class="number">1</span>, l] + cost[word[j]], fur[j, l-<span class="number">1</span>] + cost[word[l]]); <span class="comment">//不同则取小的一边</span></span><br><span class="line">   	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">outit</span>;</span></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">	<span class="comment">//assign(output, 'test.out'); rewrite(output);</span></span><br><span class="line">  	<span class="keyword">write</span>(fur[<span class="number">1</span>, m]);</span><br><span class="line">  	<span class="comment">//close(output);</span></span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">  	init;</span><br><span class="line">  	main;</span><br><span class="line">  	outit;</span><br><span class="line"><span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>题目来源：<a href="http://poj.org/problem?id=3280" title="Cheapest Palindrome">POJ3280</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给定一个长度为M（M&lt;=2000）的小写字母串</p>
<p>给定串中出现的N种字母的添加和删除代价</p>
<p>可以在任意位置加入或删除任意字母，代价如给定</p>
<p>求使原串变形为回文串的最小代价</p>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>刚开始的思路非常复杂，储存两个代价，并且递归处理</p>
<p>(left,right)之外的回文串(之间的已为回文)，然后分各种情况讨论。这又犯了想当然的毛病，而且每次都是打到一半才发现算法不完善，情况考虑未完整，影响很致命。</p>
<p>其实这题的解法很简单。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[usaco2006nov Roadblocks]]></title>
    <link href="http://houseowo.me/2012/12/14/POJ3255/"/>
    <id>http://houseowo.me/2012/12/14/POJ3255/</id>
    <published>2012-12-14T08:30:01.000Z</published>
    <updated>2016-02-21T14:55:08.000Z</updated>
    <content type="html"><![CDATA[<p>题目：Roadblocks</p>
<p>题目来源：<a href="http://poj.org/problem?id=3255" title="Roadblocks" target="_blank" rel="external">POJ3255</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给一个双向路径联通图，求节点1到节点N的第二短路(路程严格大于最短路)</p>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>刚开始想到的是直接做最短路，用一个dist存最短路，用一个dist2存第二短路，即每次更新dist[i]时，把dist[i]的原有值给dist2[i]</p>
<p>但是发现这样很蛋疼。。</p>
<a id="more"></a>
<p>因为路程严格大于最短路，所以我们只要知道数值上大于最短路的就可以了，不必担心求出来的路径和最短路一样</p>
<p>（如最短路次短路都是10，求的时候就要保证他们不是来自同一路径）</p>
<p>这样的话我们可以两头做最短路</p>
<p>然后枚举边</p>
<p>找出除最短程以外的最短路程</p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><p>spfa + 边表</p>
<h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans = min (dist<span class="string">[1,i]</span> + edg<span class="string">[i,j]</span> + dist<span class="string">[j,n]</span>)  (ans&gt;dist<span class="string">[1,n]</span>)</span><br></pre></td></tr></table></figure>
<h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><p>存双向边，数组上线翻倍</p>
<p>spfa，数组上线再翻10-20倍</p>
<p>或者用循环队列</p>
<h2 id="u6E90_u7A0B_u5E8F"><a href="#u6E90_u7A0B_u5E8F" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Program Lwx;</span><br><span class="line"><span class="keyword">Var</span> 	n, m:longint;</span><br><span class="line">    	edg:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">200100</span>, <span class="number">1</span>..<span class="number">4</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	last, first:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">5005</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	i, j, k, l, a, b, c, ans, top, fv:longint;</span><br><span class="line">    	f:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">500100</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	dist:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">2</span>,<span class="number">1</span>..<span class="number">5005</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    	past:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">5005</span>] <span class="keyword">of</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">	<span class="comment">//assign(input, 'test.in');reset(input);</span></span><br><span class="line">  	readln(n, m);</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">		readln(a, b, c);</span><br><span class="line">    		edg[i*<span class="number">2</span>-<span class="number">1</span>, <span class="number">1</span>] := a; edg[i*<span class="number">2</span>-<span class="number">1</span>, <span class="number">2</span>] := c; edg[i*<span class="number">2</span>-<span class="number">1</span>, <span class="number">4</span>] := b;</span><br><span class="line">    		<span class="keyword">if</span> first[b] = <span class="number">0</span> <span class="keyword">then</span> first[b] := i*<span class="number">2</span> - <span class="number">1</span> <span class="keyword">else</span> edg[last[b], <span class="number">3</span>] := i*<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    		last[b] := i*<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		edg[i*<span class="number">2</span>, <span class="number">1</span>] := b; edg[i*<span class="number">2</span>, <span class="number">2</span>] := c; edg[i*<span class="number">2</span>, <span class="number">4</span>] := a;</span><br><span class="line">    		<span class="keyword">if</span> first[a] = <span class="number">0</span> <span class="keyword">then</span> first[a] := i*<span class="number">2</span> <span class="keyword">else</span> edg[last[a], <span class="number">3</span>] := i*<span class="number">2</span>;</span><br><span class="line">    		last[a] := i*<span class="number">2</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">for</span> a := <span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">  	<span class="keyword">begin</span></span><br><span class="line">    		fillchar(dist[a], sizeof(dist[a]), $ff);</span><br><span class="line">    		fillchar(past, sizeof(past), <span class="keyword">true</span>);</span><br><span class="line">    		<span class="keyword">if</span> a = <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			f[<span class="number">1</span>] := <span class="number">1</span>;</span><br><span class="line">      			dist[a, <span class="number">1</span>] := <span class="number">0</span>;</span><br><span class="line">      			past[<span class="number">1</span>] := <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			f[<span class="number">1</span>] := n;</span><br><span class="line">      			dist[a, n] := <span class="number">0</span>;</span><br><span class="line">      			past[n] := <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line">    		i := <span class="number">0</span>; j := <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">while</span> i &lt; j <span class="keyword">do</span></span><br><span class="line">    		<span class="keyword">begin</span></span><br><span class="line">      			k := f[i+<span class="number">1</span>];</span><br><span class="line">      			l := first[k];</span><br><span class="line">      			<span class="keyword">while</span> l &lt;&gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">      			<span class="keyword">begin</span></span><br><span class="line">        			<span class="keyword">if</span> (dist[a, edg[l, <span class="number">1</span>]] = -<span class="number">1</span>)<span class="keyword">or</span>(dist[a, k]+edg[l,<span class="number">2</span>] &lt; dist[a, edg[l, <span class="number">1</span>]]) <span class="keyword">then</span></span><br><span class="line">        			<span class="keyword">begin</span></span><br><span class="line">          				dist[a, edg[l, <span class="number">1</span>]] := dist[a, k] + edg[l, <span class="number">2</span>];</span><br><span class="line">          				<span class="keyword">if</span> past[edg[l, <span class="number">1</span>]] <span class="keyword">then</span></span><br><span class="line">          				<span class="keyword">begin</span></span><br><span class="line">            					inc(j);</span><br><span class="line">            					f[j] := edg[l, <span class="number">1</span>];</span><br><span class="line">            					past[edg[l, <span class="number">1</span>]] := <span class="keyword">false</span>;</span><br><span class="line">          				<span class="keyword">end</span>;</span><br><span class="line">        			<span class="keyword">end</span>;</span><br><span class="line">        			l := edg[l, <span class="number">3</span>];</span><br><span class="line">      			<span class="keyword">end</span>;</span><br><span class="line">      			past[k] := <span class="keyword">true</span>;</span><br><span class="line">      			inc(i);</span><br><span class="line">    		<span class="keyword">end</span>;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	top := dist[<span class="number">1</span>, n];</span><br><span class="line">  	ans := maxlongint;</span><br><span class="line">  	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span>*m <span class="keyword">do</span></span><br><span class="line"> 	<span class="keyword">begin</span></span><br><span class="line">    		fv := edg[i, <span class="number">2</span>] + dist[<span class="number">1</span>, edg[i, <span class="number">4</span>]] + dist[<span class="number">2</span>, edg[i, <span class="number">1</span>]];</span><br><span class="line">    		<span class="keyword">if</span> (fv &lt;&gt; top)<span class="keyword">and</span>(fv &lt; ans) <span class="keyword">then</span> ans := fv;</span><br><span class="line">  	<span class="keyword">end</span>;</span><br><span class="line">  	<span class="keyword">write</span>(ans);</span><br><span class="line">  	<span class="comment">//close(input);</span></span><br><span class="line"><span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目：Roadblocks</p>
<p>题目来源：<a href="http://poj.org/problem?id=3255" title="Roadblocks">POJ3255</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<p>给一个双向路径联通图，求节点1到节点N的第二短路(路程严格大于最短路)</p>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>刚开始想到的是直接做最短路，用一个dist存最短路，用一个dist2存第二短路，即每次更新dist[i]时，把dist[i]的原有值给dist2[i]</p>
<p>但是发现这样很蛋疼。。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[usaco2006nov Corn Fields]]></title>
    <link href="http://houseowo.me/2012/12/14/POJ3254/"/>
    <id>http://houseowo.me/2012/12/14/POJ3254/</id>
    <published>2012-12-14T08:00:50.000Z</published>
    <updated>2016-02-21T14:51:35.000Z</updated>
    <content type="html"><![CDATA[<p>题目：Corn Fields</p>
<p>题目来源：<a href="http://poj.org/problem?id=3254" title="Corn Fields" target="_blank" rel="external">POJ3254</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<ol>
<li><p>给定一个12*12的矩形，每个格子为0或1，0为不能放东西，1可以</p>
</li>
<li><p>现在放东西进格子里，一个格子可以放的条件：</p>
<ul>
<li>这个格子可以放（值为1）</li>
<li>相邻的四个格子没有放</li>
</ul>
</li>
<li><p>求有几种放法</p>
</li>
</ol>
<a id="more"></a>
<p>注意到没有后效性，可以用动归做</p>
<p>以每行为阶段，以每行的放的情况为状态，压缩为二进制（N&lt;=12）</p>
<p>状态转移的约束为1），2）条件</p>
<h2 id="u89E3_u6CD5"><a href="#u89E3_u6CD5" class="headerlink" title="解法"></a>解法</h2><p>F[I,J]表示第I行，状态为J</p>
<p>这样转移方程为<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F<span class="string">[I, J]</span> = SIGMA&#123; F<span class="string">[I-1, K]</span> &#125;  (j and k=<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>当然每行的状态确定前要先检查是否符合条件1</p>
<h2 id="u4F18_u5316"><a href="#u4F18_u5316" class="headerlink" title="优化"></a>优化</h2><p>如果每行都去考虑与地图的契合性，会非常浪费时间</p>
<p>因为J包含了所有可能，K也是，这样比较J,K就会包含许多无用的状态，J不符的和K不符的</p>
<p>这样转移复杂度会达到O(2^2N)将近7000W</p>
<p>所以要进行优化，将每行的符合地图的状态预处理出来</p>
<h2 id="u8BE6_u89E3"><a href="#u8BE6_u89E3" class="headerlink" title="详解"></a>详解</h2><p>边界为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="u7EC6_u8282"><a href="#u7EC6_u8282" class="headerlink" title="细节"></a>细节</h2><p>注意要模100000000</p>
<h2 id="u6E90_u7A0B_u5E8F"><a href="#u6E90_u7A0B_u5E8F" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Program</span> Lwx;</span><br><span class="line"><span class="keyword">Const</span> md=<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">Var</span> 	n, m:longint;</span><br><span class="line">       	i, j, k, l, a, b, c:longint;</span><br><span class="line">       	f, g:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">15</span>, <span class="number">0</span>..<span class="number">5000</span>] <span class="keyword">of</span> longint;</span><br><span class="line">       	p:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">15</span>] <span class="keyword">of</span> longint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">given</span><span class="params">(x:longint)</span>;</span></span><br><span class="line"><span class="keyword">Var</span> i:longint;</span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">if</span> p[i] <span class="keyword">and</span> x = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		inc(f[i, <span class="number">0</span>]);</span><br><span class="line">		f[i, f[i, <span class="number">0</span>]]:=x;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">find</span><span class="params">(x, y:longint)</span>;</span></span><br><span class="line"><span class="keyword">Var</span> a, b, c:longint;</span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">	<span class="keyword">if</span> x = m <span class="keyword">then</span> </span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		given(y);</span><br><span class="line">		<span class="keyword">exit</span>;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	<span class="keyword">if</span> y <span class="keyword">and</span> <span class="number">1</span>= <span class="number">0</span> <span class="keyword">then</span> find(x+<span class="number">1</span>,y <span class="keyword">shl</span> <span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">	find(x+<span class="number">1</span>, y <span class="keyword">shl</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">	<span class="comment">//assign(input, 'test.in');reset(input);</span></span><br><span class="line">	readln(n, m);</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		k := <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> j :=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">read</span>(a);</span><br><span class="line">			k := k <span class="keyword">shl</span> <span class="number">1</span> + (a+<span class="number">1</span>) <span class="keyword">mod</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">end</span>;</span><br><span class="line">		p[i] := k;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	fillchar(f, sizeof(f), <span class="number">0</span>);</span><br><span class="line">	find(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	f[<span class="number">0</span>, <span class="number">0</span>] := <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">0</span>, <span class="number">1</span>] := <span class="number">0</span>;</span><br><span class="line">	g[<span class="number">0</span>, <span class="number">1</span>] := <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span> <span class="keyword">to</span> f[i, <span class="number">0</span>] <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		g[i, j] := <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> k :=<span class="number">1</span> <span class="keyword">to</span> f[i-<span class="number">1</span>, <span class="number">0</span>] <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">if</span> f[i, j] <span class="keyword">and</span> f[i-<span class="number">1</span>, k]=<span class="number">0</span> <span class="keyword">then</span> g[i, j] := (g[i, j]+g[i-<span class="number">1</span>, k]) <span class="keyword">mod</span> md;</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line">	L := <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> f[n, <span class="number">0</span>] <span class="keyword">do</span> L := (L+g[n, i]) <span class="keyword">mod</span> md;</span><br><span class="line">	<span class="keyword">write</span>(L);</span><br><span class="line">	<span class="comment">//close(input);</span></span><br><span class="line"><span class="keyword">End</span>.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目：Corn Fields</p>
<p>题目来源：<a href="http://poj.org/problem?id=3254" title="Corn Fields">POJ3254</a></p>
<h2 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h2><p>题目大意为：</p>
<ol>
<li><p>给定一个12*12的矩形，每个格子为0或1，0为不能放东西，1可以</p>
</li>
<li><p>现在放东西进格子里，一个格子可以放的条件：</p>
<ul>
<li>这个格子可以放（值为1）</li>
<li>相邻的四个格子没有放</li>
</ul>
</li>
<li><p>求有几种放法</p>
</li>
</ol>]]>
    
    </summary>
    
  </entry>
  
</feed>
